#include "std_include.hpp"

namespace components
{
	// load dvars from config and register them as "external" dvars
	// the game re-registers them and uses the values of the external dvars
	void config::load_dvars()
	{
		ctexwnd::init();

		dvars::fs_homepath = game::Dvar_FindVar("fs_homepath");

		// Load cfg file
		// T5 :: Dvar_Command / Dvar_SetFromStringByNameFromSource

		int loadedDvarCount = 0;

		if (dvars::fs_homepath)
		{
			std::ifstream cfg;

			std::string file_path = dvars::fs_homepath->current.string;
						file_path += R"(\IW3xRadiant\dvars.cfg)";

			game::printf_to_console("[CFG] Loading dvars from config 'bin/IW3xRadiant/dvars.cfg'");

			cfg.open(file_path.c_str());
			if (!cfg.is_open())
			{
				game::printf_to_console("^3|-> Could not find 'dvars.cfg' ('%s'). Loading defaults!", file_path.c_str());
				
				dvars::register_addon_dvars();
				game::glob::radiant_config_not_found = true;
				return;
			}

			std::string input;
			std::vector<std::string> args;

			// read line by line
			while (std::getline(cfg, input))
			{
				// ignore comments
				if (input.find("//") != std::string::npos) 
				{
					continue;
				}

				// ignore lines not containing ' "'
				if (input.find(" \"") == std::string::npos)
				{
					continue;
				}

#pragma warning( disable : 4305 4309 )
				// split the string on the first space following a " => 3 args (trash)
				args = utils::split(input, ' "');
#pragma warning( default : 4305 4309)

				if (args.size() != 3)
				{
					game::printf_to_console("|-> skipping line: %s :: failed to parse args", input.c_str());
					continue;
				}

				// remove trailing space on dvar name
				utils::rtrim(args[0]);
				
				// remove the leftover space on the dvar name
				//utils::erase_substring(args[0], " ");

				// Dvar_SetFromStringByNameFromSource
				game::dvar_s* dvar = game::Dvar_FindVar(args[0].c_str());

				if (dvar)
				{
					// set value from string if dvar exists
					game::Dvar_SetFromStringFromSource(args[1].c_str(), dvar, 0);
				}
				else
				{
					// register external dvar -> reinterpreted when dvars get registered internally
					dvar = game::Dvar_RegisterString(args[0].c_str(), args[1].c_str(), game::dvar_flags::external, "External Dvar");
				}

				loadedDvarCount++;
			}
		}

		else
		{
			game::printf_to_console("^3|-> fs_homepath->current.string was NULL. Loading defaults!\n");
		}

		game::printf_to_console("|-> loaded %d dvars from disk.", loadedDvarCount);
		game::printf_to_console("\n");

		// register all addon dvars
		dvars::register_addon_dvars();
		game::glob::radiant_config_loaded = true;
	}

	// :: Config_Load :: after fs_dvars where registered
	__declspec(naked) void load_config_after_fs_stub()
	{
		const static uint32_t R_Init_Func = 0x416510;
		const static uint32_t retn_addr = 0x48BCF2; // next op

		__asm
		{
			pushad;
			call	config::load_dvars;
			popad;

			call	R_Init_Func;
			jmp		retn_addr;
		}
	}


	// ~ remote_net::CFrameWnd_OnClose
	void config::write_dvars()
	{
		GET_GUI(ggui::toolbar_dialog)->save_settings_ini();
		GET_GUI(ggui::hotkey_dialog)->on_close();

		// export current dvars to a config file
		std::ofstream cfg_file;

		// path to radiant
		if (dvars::fs_homepath)
		{
			game::dvar_s* dvar;
			
			std::string	file_path = dvars::fs_homepath->current.string;
						file_path += R"(\IW3xRadiant\dvars.cfg)";

			game::printf_to_console("[CFG] Writing 'dvars.cfg'");

			cfg_file.open(file_path.c_str());

			if (!cfg_file.is_open())
			{
				game::printf_to_console("[ERR]|-> Could not create 'dvars.cfg'. Aborting!");
				return;
			}

			cfg_file << "// generated by iw3xo-radiant" << std::endl;
			
			for (auto dvarIter = 0; dvarIter < *game::dvarCount; ++dvarIter)
			{
				// get the dvar from the "sorted" dvar* list
				dvar = reinterpret_cast<game::dvar_s*>(game::sortedDvars[dvarIter]);
				
				if (!dvar)
				{
					//int realdvarCount = *game::dvarCount;
					game::printf_to_console("[ERR]|-> Dvar was invalid! Saving ...");
					break;
				}

				// do not write paths
				if (!_stricmp(dvar->name, "fs_basepath")	|| 
					!_stricmp(dvar->name, "fs_basegame")	|| 
					!_stricmp(dvar->name, "fs_game")		|| 
					!_stricmp(dvar->name, "fs_cdpath")		|| 
					!_stricmp(dvar->name, "fs_homepath"))
				{
					continue;
				}

				const char* dvarString = "%s \"%s\"\n";
				const char* dvarValue = game::Dvar_DisplayableValue(dvar);

				if (!dvarValue)
				{
					continue;
				}

				dvarString = utils::va(dvarString, dvar->name, dvarValue);
				//game::printf_to_console(dvarString);

				cfg_file << dvarString;

				dvarValue = "";
				dvarString = "";
			}
		}

		else
		{
			game::Com_Error("Error while exporting dvars to cfg.\nfs_homepath->current.string was NULL!\n");
			return;
		}

		cfg_file.close();
	}

	
	config::config()
	{
		// stub after fs_dvars where registered
		utils::hook(0x48BCED, load_config_after_fs_stub, HOOK_JUMP).install()->quick();
	}

	config::~config()
	{ }
}
