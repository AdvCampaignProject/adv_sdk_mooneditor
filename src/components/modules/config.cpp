#include "std_include.hpp"

namespace components
{
	// load dvars from config and register them as "external" dvars
	// the game re-registers them and uses the values of the external dvars
	void config::load_dvars()
	{
		//game::printf_to_console(utils::va("\n-------------- Modules -------------- \n%s\n", game::glob::loadedModules.c_str()), 0);

		// fs_homepath should be registered internally already
		dvars::fs_homepath = game::Dvar_FindVar("fs_homepath");

		// Load cfg file
		// T5 :: Dvar_Command / Dvar_SetFromStringByNameFromSource

		int loadedDvarCount = 0;

		if (dvars::fs_homepath)
		{
			std::ifstream cfgFile;

			std::string filePath = dvars::fs_homepath->current.string;
						filePath += "\\iw3r_dvars.cfg";

			game::printf_to_console("[Cfg] Executing config \"bin/iw3r_dvars.cfg\"\n");

			cfgFile.open(filePath.c_str());
			if (!cfgFile.is_open())
			{
				game::printf_to_console("|-> Could not find \"iw3r_dvars.cfg\" in \"%s\". Loading defaults!\n", dvars::fs_homepath->current.string);
				
				dvars::register_addon_dvars();
				game::glob::radiant_config_not_found = true;
				return;
			}

			std::string input;
			std::vector<std::string> args;

			// read line by line
			while (std::getline(cfgFile, input))
			{
				// ignore comments
				if (input.find("//") != std::string::npos) 
				{
					continue;
				}

				// ignore lines not containing ' "'
				if (input.find(" \"") == std::string::npos)
				{
					continue;
				}

#pragma warning( disable : 4305 4309 )
				// split the string on the first space following a " => 3 args (trash)
				args = utils::split(input, ' "');
#pragma warning( default : 4305 4309)

				if (args.size() != 3)
				{
					game::printf_to_console("|-> skipping line: %s :: failed to parse args\n", input.c_str());
					continue;
				}

				// remove trailing space on dvar name
				utils::rtrim(args[0]);
				
				// remove the leftover space on the dvar name
				//utils::erase_substring(args[0], " ");

				// Dvar_SetFromStringByNameFromSource
				game::dvar_s* dvar = game::Dvar_FindVar(args[0].c_str());

				if (dvar)
				{
					// set value from string if dvar exists
					game::Dvar_SetFromStringFromSource(args[1].c_str(), dvar, 0);
				}
				else
				{
					// register external dvar -> reinterpreted when dvars get registered internally
					dvar = game::Dvar_RegisterString(args[0].c_str(), args[1].c_str(), game::dvar_flags::external, "External Dvar");
				}

				loadedDvarCount++;
			}
		}

		else
		{
			game::printf_to_console("|-> fs_homepath->current.string was NULL. Loading defaults!\n");
		}

		game::printf_to_console("|-> loaded %d dvars from disk.\n", loadedDvarCount);
		game::printf_to_console("\n");

		// register all addon dvars
		dvars::register_addon_dvars();
		game::glob::radiant_config_loaded = true;
	}

	// :: Config_Load :: after fs_dvars where registered
	__declspec(naked) void load_config_after_fs_stub()
	{
		const static uint32_t R_Init_Func = 0x416510;
		const static uint32_t retnPt = 0x48BCF2; // next op

		__asm
		{
			pushad;
			call	config::load_dvars;
			popad;

			call	R_Init_Func;
			jmp		retnPt;
		}
	}


	// ~ remote_net::CFrameWnd_OnClose
	void config::write_dvars()
	{
		// export current dvars to a config file
		std::ofstream cfgFile;

		// path to radiant
		if (dvars::fs_homepath)
		{
			game::dvar_s* dvar;
			
			std::string	filePath = dvars::fs_homepath->current.string;
						filePath += "\\iw3r_dvars.cfg";

			game::printf_to_console("[Cfg] Writing config \"iw3r_dvars.cfg\"\n");

			cfgFile.open(filePath.c_str());

			if (!cfgFile.is_open())
			{
				game::printf_to_console("Could not create iw3r_dvars.cfg. Aborting!\n");
				return;
			}

			cfgFile << "// generated by IW3xRadiant" << std::endl;
			
			for (auto dvarIter = 0; dvarIter < *game::dvarCount; ++dvarIter)
			{
				// get the dvar from the "sorted" dvar* list
				dvar = reinterpret_cast<game::dvar_s*>(game::sortedDvars[dvarIter]);
				
				if (!dvar)
				{
					//int realdvarCount = *game::dvarCount;
					game::printf_to_console("Dvar was invalid! Saving ...\n");
					break;
				}

				// do not write paths
				if (!_stricmp(dvar->name, "fs_basepath")	|| 
					!_stricmp(dvar->name, "fs_basegame")	|| 
					!_stricmp(dvar->name, "fs_game")		|| 
					!_stricmp(dvar->name, "fs_cdpath")		|| 
					!_stricmp(dvar->name, "fs_homepath"))
				{
					continue;
				}

				const char* dvarString = "%s \"%s\"\n";
				const char* dvarValue = game::Dvar_DisplayableValue(dvar);

				if (!dvarValue)
				{
					continue;
				}

				dvarString = utils::va(dvarString, dvar->name, dvarValue);
				//game::printf_to_console(dvarString);

				cfgFile << dvarString;

				dvarValue = "";
				dvarString = "";
			}
		}

		else
		{
			game::Com_Error("Error while exporting dvars to cfg.\nfs_homepath->current.string was NULL!\n");
			return;
		}

		cfgFile.close();
	}

	
	config::config()
	{
		// stub after fs_dvars where registered
		utils::hook(0x48BCED, load_config_after_fs_stub, HOOK_JUMP).install()->quick();
	}

	config::~config()
	{ }
}
