#include "STDInclude.hpp"

namespace Components
{
	// load dvars from config and register them as "external" dvars
	// the game re-registers them and uses the values of the external dvars
	void Config::LoadDvars()
	{
		printf(Utils::VA("\n-------------- Modules -------------- \n%s\n", Game::Globals::loadedModules.c_str()), 0);

		// fs_homepath should be registered internally already
		Dvars::fs_homepath = Game::Dvar_FindVar("fs_homepath");

		// Load cfg file
		// T5 :: Dvar_Command / Dvar_SetFromStringByNameFromSource

		int loadedDvarCount = 0;

		if (Dvars::fs_homepath)
		{
			std::ifstream cfgFile;

			std::string filePath = Dvars::fs_homepath->current.string;
			filePath += "\\iw3r.cfg";

			printf("[CFG] Executing config \"bin/iw3r.cfg\"\n");

			cfgFile.open(filePath.c_str());

			if (!cfgFile.is_open())
			{
				printf(Utils::VA("|-> Could not find \"iw3r.cfg\" in \"%s\". Loading defaults!\n", Dvars::fs_homepath->current.string));
				
				Dvars::Register_AddonDvars();
				Game::Globals::radiant_config_not_found = true;
				return;
			}

			std::string input;
			std::vector < std::string > args;

			// read line by line
			while (std::getline(cfgFile, input))
			{
				// ignore comments
				if (input.find("//") != std::string::npos) 
				{
					continue;
				}

				// meh but it works
#pragma warning( disable : 4305 4309 )

				if (input.find(' "') != std::string::npos)
				{
					// split the string on the first space following a " (gets us 3 args)
					args = Utils::split(input, ' "');
				}

				else 
				{
					args.push_back(input);
				}

#pragma warning( default : 4305 4309)

				// we should always get 3 args this way
				if (args.size() != 3)
				{
					printf(Utils::VA("|-> skipping line: %s :: failed to parse args\n", input.c_str()));
					continue;
				}

				// remove the leftover space on the dvar name
				Utils::EraseSubstring(args[0], " ");

				// Dvar_SetFromStringByNameFromSource
				Game::dvar_s* dvar = Game::Dvar_FindVar(args[0].c_str());

				if (dvar)
				{
					// set value from string if dvar exists
					Game::Dvar_SetFromStringFromSource(args[1].c_str(), dvar, 0);
				}
				else
				{
					// register external dvar -> reinterpreted when dvars get registered internally
					dvar = Game::Dvar_RegisterString(args[0].c_str(), args[1].c_str(), Game::dvar_flags::external, "External Dvar");
				}

				loadedDvarCount++;
			}
		}

		else
		{
			printf("|-> fs_homepath->current.string was NULL. Loading defaults!\n");
		}

		printf(Utils::VA("|-> loaded %d dvars from disk.\n", loadedDvarCount));

		// register all addon dvars
		Dvars::Register_AddonDvars();
		Game::Globals::radiant_config_loaded = true;
	}

	// :: Config_Load :: after fs_dvars where registered
	__declspec(naked) void load_config_after_fs_stub()
	{
		const static uint32_t R_Init_Func = 0x416510;
		const static uint32_t retnPt = 0x48BCF2; // next op

		__asm
		{
			pushad;
			call	Config::LoadDvars;
			popad;

			call	R_Init_Func;
			jmp		retnPt;
		}
	}


	// ~ RemNet::CFrameWnd_OnClose
	void Config::WriteDvars()
	{
		// export current dvars to a config file
		std::ofstream cfgFile;

		// path to radiant
		if (Dvars::fs_homepath)
		{
			Game::dvar_s* dvar;
			std::string filePath = Dvars::fs_homepath->current.string;
			filePath += "\\iw3r.cfg";

			printf("[CFG] Writing config \"iw3r.cfg\"\n");

			cfgFile.open(filePath.c_str());

			if (!cfgFile.is_open())
			{
				Game::Com_Error("Could not create iw3r.cfg. Aborting!\n");
				return;
			}

			cfgFile << "// generated by IW3xRadiant" << std::endl;
			
			// loop all stock dvars and addon dvars (dvarCount is odd ...)
			//for (auto dvarIter = 0; dvarIter < STOCK_DVARCOUNT + Game::sortedDvarsAddonsCount; ++dvarIter)
			for (auto dvarIter = 0; dvarIter < *Game::dvarCount; ++dvarIter)
			{
				// get the dvar from the "sorted" dvar* list
				dvar = reinterpret_cast<Game::dvar_s*>(Game::sortedDvars[dvarIter]);
				
				if (!dvar)
				{
					//int realdvarCount = *Game::dvarCount;
					Game::Com_Error("Dvar was invalid! Saving ...\n");
					break;
				}

				// do not write paths
				if (!stricmp(dvar->name, "fs_basepath")
					|| !stricmp(dvar->name, "fs_basegame")
					|| !stricmp(dvar->name, "fs_game")
					|| !stricmp(dvar->name, "fs_cdpath")
					|| !stricmp(dvar->name, "fs_homepath"))
				{
					continue;
				}

				const char* dvarString = "%s \"%s\"\n";
				const char* dvarValue = Game::Dvar_DisplayableValue(dvar);

				if (!dvarValue)
					continue;

				dvarString = Utils::VA(dvarString, dvar->name, dvarValue);
				printf(dvarString);

				cfgFile << dvarString;

				dvarValue = "";
				dvarString = "";
			}
		}

		else
		{
			Game::Com_Error("Error while exporting dvars to cfg.\nfs_homepath->current.string was NULL!\n");
			return;
		}

		cfgFile.close();
	}

	Config::Config()
	{
		// stub after fs_dvars where registered
		Utils::Hook(0x48BCED, load_config_after_fs_stub, HOOK_JUMP).install()->quick();
	}

	Config::~Config()
	{ }
}
